指针是 C/C++ 最重要的一个概念，且使用非常频繁，当然也劝退了很多人。今天重点梳理和重新理解指针的概念，希望以最简单的思维方式来学习使用指针。

指针说白了就是一个对象，用面向过程来解释的话就应该是一个变量，它存储的数值是内存的一个地址。

弄懂指针需要了解指针的类型、指针的值、指针所指向的类型和指针所占内存区的大小4个方面的内容。我们一样样来解释吧。

例如 <code>int *ptr; </code>
ptr 是指针变量，所以指针的类型就是这个变量的类型，这里指的是int *, 如果是 char **ptr 则是 char **,int( * ptr)[4]  --》 int( * )[4] 

指针的值：指的就是指针本身存储的数值，这个值将被编译器当做一个地址，而不是一般的数值。所以一般来说指针的值其实指的是以该值为首地址的一片内存区。通俗点解释就是指针存储的是该值的地址。比如 <code>int *p = &a;</code> 指针p存储的就是值a的地址。

指针所指向的类型就是*p的类型，在<code>int *p = &a;</code> 中，指针存储的是a的地址，也可以说成指针指向a（因为通过指针p，我们能够找到a的地址，其实就是说指针p指向变量a），所以 *p 其实就是a的类型。

指针所占内存区的大小，这个很好理解，指针本身也是一个变量，变量都是有数据类型的，只不过一般都是值类型。而指针是指针类型，就是上面第一点所说的类型，指针类型的大小可以由sizeof得到。

## 引用
引用可以看成是一个已定义变量的别名。它和该变量本质上是一样的。
```
    #include <iostream>

using namespace std;

int main() {

    int a = 10;
    int &b = a;  // a 和 b的本质是一样的，b是a的小名而已

    a = 11;
    {
        int *p = &a;
        *p = 12; // 利用指针操作给a赋值12
        cout<<b<<endl;  // 尽管没有直接对b进行操作，但是这里b仍然被更改了
        cout<<a<<endl; // a 也被更改了
    }
    b = 14; // 对b进行赋值，a和b都被更改了
    cout << "a="<<a<<",b="<<b<<endl;
    return 0;
}
```
关于引用的一些概念：
1 引用没有定义,是一种关系型声明。声明它和原有某一变量(实体)的关
系。故 而类型与原类型保持一致,且不分配内存。与被引用的变量有相同的地
址。
2 声明的时候必须初始化,一经声明,不可变更。
3 可对引用,再次引用。多次引用的结果,是某一变量具有多个别名。
4 &符号前有数据类型时,是引用。其它皆为取地址。

## 引用作为函数参数
> 普通引用在声明时必须用其他的变量进行初始化，引用函数参数声明不进行初始化。
```
#include <iostream>

using namespace std;

//定义一个二叉树节点类型结构体
struct BinaryTree{
    int data;
    struct BinaryTree *lchild; // 左子树
    struct BinaryTree *rchild;  // 右子树
} ;

// 直接用指针作为参数
void printNode(BinaryTree *node1){
    node1->data=99;
    cout<<node1->data<<endl;
}

// 用引用作为参数，给传递的实参取别名，实际上是修改了实参的值
void printNode2(BinaryTree &node1){
    node1.data=13;
    cout<<node1.data<<endl;
}

// node1 和 传递的node是不同的变量，不会改变实参的值
void print3(BinaryTree node1){
    cout<<node1.data<<endl;
    node1.data=88;
    cout<<node1.data<<endl;

}
int main() {
    BinaryTree node;
    node.data = 11;
    printNode(&node);
    printNode2(node);
    printf("t1:%d\n",node.data);
    print3(node);
    printf("t1:%d\n",node.data);
    return 0;
}
```
## 引用的本质
其实 Type &a <==> Type const *a; 所以其实引用是有分配内存的大小的。只不过在使用的时候，不需要关注。
```
#include <iostream>

using namespace std;

int main() {

    int a = 10;
    int &b = a;  // b是a的别名
    int* const p = &a; // 引用的本质
    *p = 15;
    cout << "a="<<a<<",b="<<b<<endl;
    cout << "p:"<<&p<<endl; // p的地址
    cout << "p->a:"<<p<<" a:"<<&a<<" b:"<<&b<<endl; //p、a、b的地址
    return 0;
}
```
1.定义两个变量（一个实参，一个形参）
2.建立关联
3.形参去间接修改实参的值

## 引用的应用：
作为函数返回值:
如果返回值为引用可以当左值
如果返回值为普通变量不可以当左值

指针引用

const引用：
> const引用的目的是禁止通过修改引用值来改变被引用的对象。<code>const int & e <==> const int * const e </code>
- const对象的引用必须是const的，将普通引用绑定到const对象上是不合法的。因为对象是const即表示不可被修改，引用当然也不能被修改，必须使用const引用。
- const引用可使用相关类型的对象初始化






