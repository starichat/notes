# 单例模式
> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
这个解释足够简单。说白了就是假如我们希望我们在我们的系统中该类仅仅存在1个或0个该类的实例。虽然单例模式很简单，但是熟悉java的同学可能了解，单例模式有很多写法,懒汉式、饿汉式、双重锁。。。 这么多形式，难道有什么目的？确实，不过他们的目的很明确，就是保证在一种特殊情况下的单例-并发。

下面结合代码看看最简单的单例：
```
package manager
import (
    "fmt"
)

var m *Manager

func GetInstance() *Manager {
    if m == nil {
        m = &Manager {}
    }
    return m
}

type Manager struct {}

func (p Manager) Manage() {
    fmt.Println("manage...")
}
```
> 这就是一个最简单的单例了，对于Manager结构体，我们提供了一个GetInstance函数去获取它的实例，这个函数中首先去判断m变量是否为空，如果为空才去赋值一个Manager的指针类型的值，一个小小的判断，就保证了我们在第第二次调用GetInstance的时候直接返回m，而不是重新获取Manager的实例，进而保证了唯一实例。

> 我们用单例的目的是为了保证在整个系统中存在唯一的实例，我们加锁的目的是为了在并发的环境中单例依旧好用。不过虽然单例简单，我们还是不能任性的用，因为这样做实例会一直存在内存中，一些我们用的不是那么频繁的东西使用了单例就造成了内存的浪费。
