# go 内存管理
> Goland 的内存管理原理基于 tcmalloc 原理，但是 Goland 在实现的时候还是做了很多优化，我们下面通过源码来看一下 Goland 的内存管理。

首先了解一下操作系统进程内存布局




## 进程内存布局详解
> 代码经过预处理，编译，汇编，链接4步后生成一个可执行程序。
用<code>size binery_file</code> 可以计算一个程序所占用的内存空间，在程序编译完成后就可以确定。
```
__TEXT  __DATA  __OBJC  others  dec     hex
1466368 266568  0       16894984        18627920        11c3d50 
```
编译后的程序主要有以下分区：
* 代码区(text)
存放CPU执行的机器指令，通常代码区是可共享的，使其可以共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，防止被恶意修改。

* 全局初始化区/静态数据区(data)
包含了在程序中明确被初始化的全局变量，已经初始化的静态变量。

* 未初始化数据区（bss）
存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（nil）。
程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。
然后，运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。

* stack
栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。栈是自顶向下扩展，栈是有界的（系统为 stack 区域保留了 128M 内存地址空间）
在程序运行期间实时加载和释放。因此，局部变量的生存周期为申请到释放该段栈空间。

* heap
堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。
根据语言的不同，如C语言、C++语言，一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。
Go语言、Java、python等都有垃圾回收机制（GC），用来自动释放内存。

贴图：进程内存分区模型
前三块区域在程序运行前就已经可以确定，同时，共享内存映射区域一般是指，通过 maps 来实现。
2. Go runtime 内存分配
>
1. 每次申请一大块内存
2. 将申请的大块内存进行分配
3. 为对象分配内存
4. 回收对象内存
5. 如果闲置内存过多，则尝试归还部分内存给操作系统，降低整体开销。

> 内存分配器只管理内存块，并不关心对象状态，而且不会主动回收，垃圾回收机制在完成清理操作后，触发内存分配器的回收操作。

## 内存管理单元
从上一节，我们知道了 go 语言通过内存管理器管理内存
我们先来搞清楚几个概念
1. 物理内存与虚拟内存
内存分配器都需要由底层操作系统管理的虚拟内存空间(Virtual Memory Space)

由于实际物理内存的限制，因此每个进程都在其自己的内存沙箱中运行-“虚拟地址空间”，即虚拟内存。

虚拟地址空间中字节的地址不用和地址总线上放置的地址相同。因此，必须建立转换数据结构和系统，以将虚拟地址空间中的字节映射到物理内存地址上的字节。

因此，当cpu执行引用内存地址的指令时，第一步是将虚拟地址中的逻辑地址转换为线性地址。这个工作就是有内存管理单元来执行的。

下面就进入正题，go内存管理单元如何管理内存的。

go 引入内存分配器，将内存分为多个级别，以减少锁的粒度。在TCmalloc内部，内存管理分为两个部分，线程内存和页堆。

## 内存分配器
## TCMalloc
TCMalloc（thread cache malloc）的核心思想是将内存划分为多个级别，以减少锁的粒度。在TCMalloc内部，内存管理分为两部分：线程内存和页堆(page heap)。
1. 线程内存(thread memory)
2. 页堆(page heap)



## Go 内存管理
在go语言中，真正执行功能的是goroutine。所有内存管理自然和goroutine分不开。

G：Goroutine执行的上下文环境
M：操作系统线程
P：Processer

1. 逃逸分析

2. 关键数据结构
1. mcache: per-P cache，可以认为是 local cache。
2. mcentral: 全局 cache，mcache 不够用的时候向 mcentral 申请。
3. mheap: 当 mcentral 也不够用的时候，通过 mheap 向操作系统申请。

内存分配过程：
1. 向 mcache 申请
2. mcache不足的话向mcentral申请填充
3. mcentral不足则向mheap申请
4. mheap不足的话，向操作系统申请

我们在源代码中跟一下步骤。

## go 内存管理细节
内存结构：
spans bitmap arena
存放span指针，每个指针指向arena的一个page
用于保存arena对应的某个地址是否存在对象，以及对象是否被gc扫描过
arena由一个个的page组成

arena 就是我们所说的heap

heap中按照管理和使用两个唯独可认为存在两类东西：

一类是从管理分配角度，由多个连续的页组成的大块内存。

mspan可以说是go内存管理的最基本单元，但是内存的使用最终还是要落脚到“对象”上。mspan和对象是什么关系呢？
对象放到page上，毕竟page才是内存存储的基本单元。

将span分配为67个大小不同的span块，然后分配对象的时候，根据对象大小进行选择大小相近的span。

bitmap




