# 学习 c/c++ 自然离不开其核心内容--指针
上一篇博文已经很详细的介绍了指针，[点击这里，可查看]()。因为 C++ 里增加了引用的概念。

引用可以看成是一个已定义变量的别名。它和该变量表示的东西是一样的。同时，引用一旦确定了，就无法再更改，比如王五的别名叫二狗子，那么二狗子就是王五的引用，就是说二狗子今年了25岁了，那王五也是25岁。但是二狗子就不能再去当张三的引用，二狗子只能和王五建立关联。同时，王五也可以有其他的别名，比如三狗子。。。。
```
#include <iostream>

using namespace std;

int main() {

    int a = 10;
    int &b = a;  // a 和 b的本质是一样的，b是a的小名而已
   
    a = 11;
    {
        int *p = &a;
        *p = 12; // 利用指针操作给a赋值12
        cout<<b<<endl;  // 尽管没有直接对b进行操作，但是这里b仍然被更改了
        cout<<a<<endl; // a 也被更改了
    }
    b = 14; // 对b进行赋值，a和b都被更改了
    cout << "a="<<a<<",b="<<b<<endl;
    return 0;
}
```
## 引用的作用
先区分一下引用和指针：
- 引用被创建的同时，必须被初始化（指针可以在任何时候被初始化
- 不能有NULL引用，引用必须与合法的存储单元关联（指针可以使NULL）
- 一旦引用被初始化，就不能改变引用的关系（指针可以随便改变所指的对象）。

引用一般作为函数参数和返回值
1. 作为函数参数
C++中，函数的参数和返回值，一般有三种传递方式：值传递、指针传递和引用传递。
其实，指针传递本质也是值传递，只不过它传递的地址值。

值传递：：值传递,值传递传递的外部变量的一份拷贝，即副本，即函数体内的操作都是对该副本的操作，不会改变原始值的大小。

```
void swap(int x,int y){
    int temp = x;
    x = y;
    y = temp;
}
```
指针传递也是一种值传递，只不过它的值是地址值。
```
void swap1(int *x, int *y)
{   
    // x、y是地址值,他是外部变量实参的一份拷贝。这里不会改变地址值的大小，但是该地址指向的内容可以发生改变。
    cout<<*x<<"-"<<*y<<endl;
    int temp = *x;
    *x = *y;
    *y = temp;
}
```
引用传递：参数是外部变量的一个引用，改变引用的值就是改变实参的值
```
void swap2(int &x,int &y){
    int temp = x;
    x = y;
    y = temp;
}
```

测试代码：
```
int main()
{
    int x = 10,y=15;
    swap(x,y);
    cout<<x<<","<<y<<endl;
    cout<<"x,y的地址"<<endl;
    cout<<&x<<","<<&y<<endl;// x、y的地址没有发生过改变，但是值变了
    swap1(&x,&y);
    cout<<&x<<","<<&y<<endl;
    swap2(x,y);
    cout<<x<<","<<y<<endl;

}
```

注意在指针传递的使用，如果是这样：
```
void swap2(int *x,int *y){
    int *temp = x;
    x = y;
    y = temp;
}
```
这样没有交换成功是因为：这里把副本指针地址交换了，但是并不会改变外部变量额值。

> 所以如果的确只需要借用一下某个对象的"别名"，那么就用"引用"，而不要用"指针"，以免发生意外。其他情况依然用指针。

2. 做返回值
