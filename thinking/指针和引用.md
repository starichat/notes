# 学习 c/c++ 自然离不开其核心内容--指针
上一篇博文已经很详细的介绍了指针，[点击这里，可查看]()。因为 C++ 里增加了引用的概念。

引用可以看成是一个已定义变量的别名。它和该变量表示的东西是一样的。同时，引用一旦确定了，就无法再更改，比如王五的别名叫二狗子，那么二狗子就是王五的引用，就是说二狗子今年了25岁了，那王五也是25岁。但是二狗子就不能再去当张三的引用，二狗子只能和王五建立关联。同时，王五也可以有其他的别名，比如三狗子。。。。
```
#include <iostream>

using namespace std;

int main() {

    int a = 10;
    int &b = a;  // a 和 b的本质是一样的，b是a的小名而已
   
    a = 11;
    {
        int *p = &a;
        *p = 12; // 利用指针操作给a赋值12
        cout<<b<<endl;  // 尽管没有直接对b进行操作，但是这里b仍然被更改了
        cout<<a<<endl; // a 也被更改了
    }
    b = 14; // 对b进行赋值，a和b都被更改了
    cout << "a="<<a<<",b="<<b<<endl;
    return 0;
}
```
## 引用的作用
先区分一下引用和指针：
- 引用被创建的同时，必须被初始化（指针可以在任何时候被初始化
- 不能有NULL引用，引用必须与合法的存储单元关联（指针可以使NULL）
- 一旦引用被初始化，就不能改变引用的关系（指针可以随便改变所指的对象）。

引用一般作为函数参数和返回值
1. 作为函数参数
C++中，函数的参数和返回值，一般有三种传递方式：值传递、指针传递和引用传递。
其实，指针传递本质也是值传递，只不过它传递的地址值。

值传递：：值传递,值传递传递的外部变量的一份拷贝，即副本，即函数体内的操作都是对该副本的操作，不会改变原始值的大小。

```
void swap(int x,int y){
    int temp = x;
    x = y;
    y = temp;
}
```
指针传递也是一种值传递，只不过它的值是地址值。
```
void swap1(int *x, int *y)
{   
    // x、y是地址值,他是外部变量实参的一份拷贝。这里不会改变地址值的大小，但是该地址指向的内容可以发生改变。
    cout<<*x<<"-"<<*y<<endl;
    int temp = *x;
    *x = *y;
    *y = temp;
}
```
引用传递：参数是外部变量的一个引用，改变引用的值就是改变实参的值
```
void swap2(int &x,int &y){
    int temp = x;
    x = y;
    y = temp;
}
```

测试代码：
```
int main()
{
    int x = 10,y=15;
    swap(x,y);
    cout<<x<<","<<y<<endl;
    cout<<"x,y的地址"<<endl;
    cout<<&x<<","<<&y<<endl;// x、y的地址没有发生过改变，但是值变了
    swap1(&x,&y);
    cout<<&x<<","<<&y<<endl;
    swap2(x,y);
    cout<<x<<","<<y<<endl;

}
```

注意在指针传递的使用，如果是这样：
```
void swap2(int *x,int *y){
    int *temp = x;
    x = y;
    y = temp;
}
```
这样没有交换成功是因为：这里把副本指针地址交换了，但是并不会改变外部变量额值。比如我们看下面代码，打印出swap函数的x、y指针的地址值和实参的地址值。


> 所以如果的确只需要借用一下某个对象的"别名"，那么就用"引用"，而不要用"指针"，以免发生意外。其他情况依然用指针。
> 指针的指针和指针：指向指针的指针的作用 :当要修改实参指针的指向的时候，形参必须使用指向指针的指针。当修改的是实参指针指向的内容时，则形参只需是指针即可

2. 做返回值
当函数返回值作为引用时，如果返回栈变量不能成为其他引用的初始值，就不能作为函数返回值。

- 不能返回局部变量的引用：局部变量在函数返回后会被销毁，因此被返回的引用就成为了“无所指”的引用，程序会进入未知状态。
- 不能返回函数内部分配的内存的引用。对于函数内部new分配内存的引用，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间就无法释放，造成内存不够。
- 可以返回类成员的引用，最好是const。| 主要原因是当对象的属性与某种业务规则相关联的时候，其赋值常常与某些其他属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。
- 引用与一些操作符的重载


3. const 引用
