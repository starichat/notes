# 「浅」谈认证授权

> 平时开发中，我们可能直接用到了很多安全框架，但是很多时候，我们只知道怎么用，却不知所以然。涉及到互联网服务，就涉及到身份认证。这里所说的认证其实包含了两个部分「认证」和「授权」
* 认证：指的是当前用户的身份，当用户登陆过后，系统便能追踪到他的身份作出符合相应的业务逻辑的操作。即是用户没有登陆，大多数系统也能追踪到他的身份，只是当作来宾或者匿名用户来处理。认证技术解决的是“我是谁”的问题.
* 授权：指的是什么样的身份被允许访问某些资源，在获取到用户身份后继续检查用户的权限。来解决用户能访问什么样的资源。

下面我们以实际的一个例子来了解认证授权的「前世后生」

> 在微服务架构中，我们需要保证我们提供的接口能够被合法调用，没有经过认证的「用户」无法访问我们的接口。那么我们应该如何设计一套鉴权框架呢？

## 传统方案
如何实现这样一个鉴权方案，鉴权无非就是验证用户名密码，那么「用户」将用户名和密码随请求url一起传递到服务端，服务端进行验证，如果是合法用户则允许访问。流程可以类似如下设计：
1. 客户端直接请求 url？username=XXX&password=XXXX
2. 服务端接受请求，验证username 和 password 是否合法，合法则允许访问，否则拒绝访问

是不是解决问题？在信息泄漏如此严重的今天，这样明文传递密码合适吗？这样密码很容器被截取，所以，我们需要借助加密算法对密码进行加密，请求前，我们将用户信息类似 username:password 构造，并采用base64加密后，随请求一起传递给服务端。这种方式叫做 「HTTP Basic」，应该算是最早期的http认证手段了，但是base64只是编码规则，而不是加密算法，所有用base64加密后的内容基本等于明文。那么我们使用SHA等加密算法进行机密再传输就好了嘛。流程如下：
1. SHA（url？username=XXX&password=XXXX）
2. 服务端解析请求，从中解析出用户信息
3. 认证用户信息，如果合法，则允许访问，否则拒绝访问
这样看似是完美的，但是因为http协议是无状态的，他不需要建立请求方和调用方的关系，因此，请求方的数据很容器被「中间人」截获，并实施「重放攻击」。

> 重放攻击：
https://juejin.im/post/5ad43b86f265da239236cedc

虽然我们的请求是加密的，但是黑客可以拦截我们的请求，并不解析请求，获取到请求结果后再转发给用户，用户毫不察觉，并通过借助此次请求持续不停地请求资源服务器。

## oauth 策略
一步步提出问题，一步步解决问题，正式互联网开发的一个好的方式。一步步迭代优化，最终得到我们需要的方式。oauth策略在「用户」和服务端设置一个授权层，「用户」在请求接口的时候将请求地址，username，password拼接在一起，进行加密生成token，然后将这个token和username随url一起传递给服务端，服务端收到这些数据后，根据username从「数据库」中取出密码，基于「用户」生成token的算法，也生成服务端token，如果一致则认证成功，否则失败。流程如下：
客户端：
1. SHA(url?username=xxx&password=xxxx)
2. url?username=xxx&token=xxx 
服务端
3. 解析url，username，token
4. 从持久层取oassword，并生成服务端token
5. 验证服务端token和客户端token是否一致，一致则可以访问接口，否则拒绝访问

上面这一通操作，将提供资源服务和认证授权服务分开了，隔离出了一个认证授权服务层，但是这样就可以一劳永逸了吗？因为，生成的token是固定的，所以，还是没法避免「重放攻击」。解决办法就是，我们给token设置一个有效时间嘛，优化一下token的生成算法，给生成token的算法中加入时间戳，服务端解析之后需要增加一步查看时间戳是否过期的需求。流程如下：
1. 生成token
2. 生成url
3. 请求服务端
4. 服务端解析url，appid，token，ts
5. 验证token是否失效
6. 从数据库中取出数据验证
7. 生成服务端token
8. 校验服务端token和客户端token

我们结合代码看下类似这样一个认证授权的功能如何实现：
结合面向对象的设计理念，作出如下设计：
1. 对象设计
### AuthToken
* 生成token算法
* 验证token是否匹配
* 验证是否token有效

### APIRequest 
* 拼接形成新的url
* 解析url信息

### CredentialStorage
* 从持久层取出username对应的密码
2. 业务处理
### APIAuthebcator
* 接受url进行并进行认证

看下代码实现
```

```
这里只列出了业务逻辑的处理，完整代码访问 xxxx ，或者「阅读原文」即可查看。

## 总结
最终，我们做到了绝对的安全了吗？没有，也不存在绝对的安全，我们将黑客拦截时间控制到了一分钟以内，在接口处理效率和安全之间做到了一个合适的处理，过度设计容易导致接口效率变低，由此看来，损失可能更大，攻防之间从来都没有绝的，我们所做的不过就是增加攻击的成本。针对上述设计，我们还可以做一些ip，访问次数。。。等限制，对一些安全级别比较高的接口，可以实施，一般的需求，以上设计就足够了。同时对于将加密算法暴露给客户端，确实也是不安全的行为，客户端极易被破解。所有，就衍生出了「JWT技术」

## jwt
1. 用户使用用户名和口令到认证服务器上请求认证
2. 认证服务器验证用户名和口令后，以服务器端生成JWT Token，这个token的生成过程如下
 * 认证服务器还会生成一个 Secret Key（密钥）
 * 对JWT Header和 JWT Payload分别求Base64。在Payload可能包括了用户的抽象ID和的过期时间。
 * 用密钥对JWT签名 HMAC-SHA256(SecertKey, Base64UrlEncode(JWT-Header)+'.'+Base64UrlEncode(JWT-Payload));
3. 然后把 base64(header).base64(payload).signature 作为 JWT token返回客户端。
4. 客户端使用JWT Token向应用服务器发送相关的请求。这个JWT Token就像一个临时用户权证一样。 

客户端每次携带该token进行请求即可，应用服务器每次会验证该token是否过期，是否可用。为了保证安全，这里会缩短token有效期，但是有效期太短又会影响用户体验，所以这里一般有两种解决方案：
1. 提供access_token 该token有效期较长，refresh_token 该token用来刷新access_token
2. 短期的后台token刷新策略，token有效期很短，当token过期后，必须用当前token去获取新的token。
