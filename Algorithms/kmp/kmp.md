# kmp 算法详解

> example :
> "bacbababadababacambabacaddababacasdsd"
> ababaca

> 一般匹配字符串的时候，我们从目标字符串的第一个下标选取和模式串一样长度的子字符串进行比较，如果一样，就返回开始处的下标值，不一样，选取str的一个下标，同样取长度为m的字符串进行比较，直到str的末尾，这样时间复杂度为O(mn)

时间复杂度太复杂了，如何优化呢？
我们在进行比较的时候，其实有很多字符串是重复的，所以我们首先应该实现一个最大的移动量，这里我们需要计算处一个长度为m的转移函数next

next函数作用：
1. 返回一个固定字符串的最长前缀和最长后缀 本例中的最长前缀和最长后缀就是abc了，就是前面和后面的值相同的大小，当然也存在为空的情况
2. 最长前缀表示的从第一个字符开始到最后一个字符结束，不包括最后一个字符
3.  对于本例中 ababaca 长度为7 ， 所以 next[0],1,2,3,4,5,6 分别为：a,ab,aba,abcb,ababa,ababac,ababaca的相同的最长前缀和最长后缀的长度，不存在返回为-1，即为[-1,-1,0,-1,2,-1,0] 0 表示存在长度为1，2表示存在为为3

```
